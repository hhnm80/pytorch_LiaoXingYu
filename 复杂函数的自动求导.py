# 上面我们展示了简单情况下的自动求导，都是对标量进行自动求导，可能你会有一个疑问，如何对一个向量或者矩阵自动求导了呢？感兴趣的同学可以自己先去尝试一下，下面我们会介绍对多维数组的自动求导机制。
# coding=utf-8
import torch
from torch.autograd import Variable
# 这里面,在构建张量或者说构建数组的时候,有其形还要有其质,形就是矩阵的形状,质就是矩阵里面存储的数据,m的shape是(1,2),口诀"从外向里,从左往右"
m = Variable(torch.FloatTensor([[2, 3]]), requires_grad=True) # 构建一个 1 x 2 的矩阵

# 在构建0矩阵或者1矩阵的时候,我们需要了解的是Variable这个函数,关于这个函数的定义,我们可以百度之,就是把张量加入到一个节点里面,这种数据有grad属性，而torch数据没有该属性,torch的函数一般都与张量有关,而数组是numpy里面特有的,,,,,,,
# n不需要梯度么??????不需要梯度难道是常数么?????
n = Variable(torch.zeros(1, 2)) # 构建一个相同大小的 0 矩阵
print("m的值是:",m)
print("n的值是",n)

# 通过 m 中的值计算新的 n 中的值,这语句是什么意思呢?????是什么意思呢????以前没见过这种格式,这式子是什么意思呢????写得这么复杂,其实呢,这个是复合下标,只是python语言的语法太灵活了,所以才第一次见到这种写法,第一次见到,在c语言里面,二维数组,假设有一个二维数组,当然,我们现在用c语言表示二维数组,int a[3][4]={{1,2,3,4},{5,6,7,8},{9，10,11,12}};那么我们可以知道a[0][0]是什么东西呢????就是第一行第一列,同理,在这里是python语言的表达形式,m[0,0]就是m这个矩阵第一行第一列的数字,显然是2,2的2次方是4,把4赋值给n这个矩阵第一行第一列,简而言之,就是n中的元素是m中对应元素的乘方,显然,n中只有两个元素,第一个元素的值是m第一个元素值的平方,第二个元素是m第二个元素值的立方,2的平方,3的立方.......
n[0, 0] = m[0, 0] ** 2
# 把m矩阵第一行,第二列 进行立方运算,就是3的3次方,值为27,赋值给n矩阵第一行第二列,

n[0, 1] = m[0, 1] ** 3

#故新的n矩阵是[[4,27]]
print(n)

# 下面我们直接对n进行反向传播,也就是n对m的导数,反向传播就是反推,因为n是由m演化而来,m是自变量,n是变量,换个名字说,就是y对x求导,上级对下级求导,就是反向追溯,所以叫做反向传播,,,,
# 在 PyTorch 中，如果要调用自动求导，需要往 backward() 中传入一个参数，这个参数的形状和 n 一样大，backward是一个自动求导函数,假设输入层有两个参数x和y,这两个参数x和y,x和y可以取任意值,x和y作为最基础的变量,以后神经元里面任何变量都是由x和y以及权重参数演化而来,多元函数对单个变量求导就是偏导,,,,

# ones_like这个函数名字有点意思,如果只是ones函数,就是生成的张量(矩阵)里面

n.backward(torch.ones_like(n)) # 将 (w0, w1) 取成 (1, 1)